#!/bin/bash

### BEGIN INIT INFO
# Provides: Factorio Server Manager
# Required-Start: $local_fs $network $remote_fs
# Required-Stop: $local_fs $network $remote_fs
# Default-Start:  2 3 4 5
# Default-Stop: 0 1 6
# Short-Description: Administration tool for Factorio.
# Description: A management and init script for Factorio server(s).
### END INIT INFO

# Configuration
configuration_dir='/etc/factorio/'
install_dir='/opt/factorio/'
log_dir='/var/log/factorio/'

run_user='factorio'
sudo_group='sudo'

# Script variables, do not modify.
DRYRUN=1
LOGLEVEL=9

date_format='%Y-%m-%d_%H:%M:%S'

log_file="${0}.log"
script_start=`date +"${date_format}"`

# Server package download URLs
f_url='https://www.factorio.com/download-headless'
f_url_experimental='https://www.factorio.com/download-headless/experimental'


function now {
  echo -e `date +"${date_format}"`
}

function runAsUser {
  if [ "`whoami`" == "${run_user}" ]; then
    bash -c "$1"
  else
    sudo su "${run_user}" -s /bin/bash -c "$1"
  fi
}


# Logging function
function logThis {
  if [[ $1 =~ ^[0-9]+$ ]];then
    if [ ${LOGLEVEL} -ge $1 ];then
      echo `now` [level=$1]: $2 | runAsUser "tee -a ${log_dir}${log_file}"
    else
      runAsUser "echo `now` [level=$1]: $2 >> ${log_dir}${log_file}"
    fi
  fi
}

# Check if a user has sudo access
# usage: if [ checkSudo ];then sudo <command>;else;<error>;fi
# return: 0 if sudo, 1 if not
function checkSudo {
  local sudo_test=$(sudo -v 2>&1)
  if [ -z "${sudo_test}" ];then
    return 0
  fi
  return 1
}

# Set up folder defaults, non-destructively
function folderDefaults {
  if [ checkSudo ];then
    if [ ! -d ${log_dir} ] || [ ! -d ${install_dir} ] || [ ! -d ${configuration_dir} ];then
      sudo mkdir -p ${log_dir} ${install_dir} ${configuration_dir}
    fi
    
    if [[ ! "`id -u ${run_user} 2>&1`" =~ ^[0-9]+$ ]];then
      logThis 0 "Creating user '${run_user}'..."
      sudo useradd "${run_user}" --system --create-home --home-dir "/home/${run_user}" --comment "Autogenerated user for Factorio server execution."
      logThis 0 "User '${run_user}' created"
    fi
    
    sudo chown -R ${run_user}:${sudo_group} ${log_dir} ${install_dir} ${configuration_dir}
    sudo chmod ug+wrx ${log_dir} ${install_dir} ${configuration_dir}
  else
    logThis 0 'ERROR: No sudo privileges!'
  fi
}

function fileDefaults {
  if [ checkSudo ];then
    if [ ! -f "${log_dir}${log_file}" ];then
      sudo touch ${log_dir}${log_file}
    fi
  else
    logThis 0 'ERROR: No sudo privileges!'
  fi
}

function init {
  if [ checkSudo ];then
    folderDefaults
    fileDefaults
    
    logThis 1 'Checking for existing servers...'
    # @TODO - check for old format servers and installed tools/packages, offer to migrate them (use rsync and diff to ensure folder integrity)
    logThis 1 'No servers found.'
    
  else
    logThis 0 'ERROR: No sudo privileges, cannot run initialization!'
  fi
}

function tailLog {
  runAsUser "tail -20 ${log_dir}${log_file}"
}
function clearLog {
  local temp_log='/tmp/cleared.log'
  runAsUser "grep 'Log cleared' ${log_dir}${log_file} > ${temp_log}"
  runAsUser "cat ${temp_log} > ${log_dir}${log_file}"
  logThis 0 "Log cleared at '`now`' by `whoami`."
  runAsUser "rm -rf /tmp/cleared.log"
}

# Display usage information.
function usageHelp {
  echo
  echo "Available commands:"
  echo -e "\t help \t\t\t displays usage help."
  if [ checkSudo ];then
    echo -e "\t init \t\t\t creates folders and files for configuration and logging. (sudo only)"
  fi
  echo -e "\t log \t\t\t shows the last 50 lines of the manager log."
  if [ checkSudo ];then
    echo -e "\t log clear \t\t empties the manager log. (sudo only)"
  fi
  echo
  echo "Available (optional) variables:"
  echo -e "\t\$LOGLEVEL\tdefault is '1' \t\t displays extra function status and debugging text if set to non-zero"
  echo -e "\t\$DRYRUN\t\tdefault is '1' \t\t prints output and check results, but doesn't actually write any values"
  echo
}


function cleanup {
  wait
  if [ $LOGLEVEL -ne 0 ];then
    logThis "Done, fmanager exiting."
  fi
}

# On exit, do cleanup
trap cleanup EXIT


# Check if variables are instantiated before setting to defaults
# @TODO - stop using magic numbers
if [ -z $UNRECOGNIZED ];then
  UNRECOGNIZED=0
fi
if [ -z $HELP ];then
  HELP=0
fi
if [ -z $DRYRUN ];then
  DRYRUN=1
fi
if [ -z $LOGLEVEL ];then
  LOGLEVEL=1
fi
if [ -z $DOINIT ];then
  DOINIT=0
fi
if [ -z $UPDATECACHE ];then
  UPDATECACHE=0
fi
if [ -z $LOG ];then
  LOG=0
fi

# If no commands are passed in, display help
if [ -z "$*" ];then
  HELP=1
else
  for i in "$@"; do
    case "$i" in
      --log-level=^[0-9]$|-l=^[0-9]$)
        # Get the passed in value
        LOGLEVEL=$(echo "${i}" | cut -d'=' -f2)
      ;;
      --dry-run|--dry-run=true)
        DRYRUN=1
      ;;
      --dry-run=false)
        DRYRUN=0
      ;;
      --help|help|-h|h)
        HELP=1
      ;;
      init)
        DOINIT=1
      ;;
      log)
        LOG=1
      ;;
      clear)
      ;;
      update)
        UPDATECACHE=1
      ;;
      *)
        UNRECOGNIZED=1
      ;;
    esac
  done
fi

# Warn the user if their command isn't recognized.
if [ ${UNRECOGNIZED} -ne 0 ];then
  command_string=`echo "${0} ${@}"`
  logThis 0 "Command '${command_string}' not recognized!"
  unset command_string
  HELP=1
else
  command_string=`echo "${0} ${@}"`
  logThis 9 "Command '${command_string}' executed by user '`whoami`'."
  unset command_string
  
fi

# Display help
if [ ${HELP} -ne 0 ];then
  LOGLEVEL=0
  usageHelp
  exit 0
fi

# Refuse to continue if essential files and folders don't exist.
if [ -z "${configuration_dir}" ];then
  logThis 0 "Configuration directory (configuration_dir) variable not set!"
  logThis 0 "This is an error, exiting!"
  exit 1
fi



# @TODO - add (optional, based on sudo permissions) auto-init?
# eg "looks like you don't have a $CONFIG folder, create now? [y/N]" prompt
if [ ${DOINIT} -ne 0 ];then
  init
fi

function logging {
  local clear_log=0
  local display_log=1

  for i in "$@"; do
    case "$i" in
      clear)
        clear_log=1
        display_log=0
      ;;
    esac
  done

  if [ ${display_log} -ne 0 ];then
    tailLog
  fi
  
  if [ ${clear_log} -ne 0 ];then
    clearLog
  fi
}

if [ ${LOG} -ne 0 ];then
  logging
fi

# Handle updating
if [ $UPDATECACHE -ne 0 ];then
  # Get HTTP status of update URLs
  local f_url_status=`curl -s -I ${f_url} | head -1 | cut -d' ' -f 2`
  local f_url_experimental_status=`curl -s -I ${f_url_experimental} | head -1 | cut -d' ' -f 2`

  if [ "${f_url_status}" -ne 200 ];then
    logThis 0 "Factorio server URL returning '${f_url_status}'."
    logThis 0 "Cannot perform update until this is resolved!"
    exit 1
  fi
  if [ "${f_url_experimental_status}" -ne 200 ];then
    logThis 0 "Factorio EXPERIMENTAL server URL returning '${f_url_experimental_status}'."
    logThis 0 "Cannot perform update until this is resolved!"
    exit 1
  fi
fi


exit 0


# List of commands from
# https://github.com/factoriommo/factorio-multienv-ctl/blob/730e6cf495e4a4fe5e1530aec0e6a26465c28f89/factorio#L53-L71
# To be implemented:
# start \t\t Starts the server
# stop \t\t Stops the server
# restart \t\t Restarts the server
# status \t\t Displays server status
# players-online \t Shows online players
# players \t\t Shows all players
# cmd [command/message] Open interactive commandline or send a single command to the server
# chatlog [--tail|-t]   Print the current chatlog, optionally tail the log to follow in real time
# new-game name\t Stops the server and creates a new game with the specified name
# save-game name \t Stops the server and saves game to specified save
# load-save name \t Stops the server and loads the specified save
# install tarball \t Installs the server with specified tarball
# update [--dry-run] \t Updates the server
# invocation \t\t Outputs the invocation for debugging purpose
# listcommands \t List all init-commands
# listsaves \t\t List all saves
# version \t\t Prints the binary version
